
import os

try:
    from dotenv import load_dotenv
    load_dotenv()

    MODEL_NAME = os.environ.get("GOOGLE_GENAI_MODEL", "gemini-2.0-flash")
except ImportError:
    print("Warning: python-dotenv not installed. Ensure API key is set")
    MODEL_NAME = "gemini-2.0-flash"

from google.adk.agents import LlmAgent, BaseAgent, SequentialAgent
from google.adk.agents.invocation_context import InvocationContext
from typing import AsyncGenerator
import asyncio
import json
from json_repair import repair_json

from learnLite.instructions import (
    CURRICULUM_PLANNER_INSTRUCTION,
    COURSE_CONTENT_GENERATOR_INSTRUCTION,
    QUIZ_MAKER_INSTRUCTION
)
# 1. Agent to plan curriculum for a given topic
curriculum_planner_agent = LlmAgent(
    name="CurriculumPlanner",
    model=MODEL_NAME,
    instruction=CURRICULUM_PLANNER_INSTRUCTION,
    output_key="curriculum"
)

# 2. Content Generator Agent
content_generator_agent = LlmAgent(
    name="CourseContentGenerator",
    model=MODEL_NAME,
    instruction=COURSE_CONTENT_GENERATOR_INSTRUCTION,
    output_key="course_content"
)

#3. Agent to generate questions and answers
quiz_maker = LlmAgent(
    name="QuizMaker",
    model=MODEL_NAME,
    instruction=QUIZ_MAKER_INSTRUCTION,
    output_key="quiz"
)
#4. Daily Course Instructor Agent
course_instructor = LlmAgent(
    name="CourseInstructor",
    model=MODEL_NAME,
    instruction="""You are an expert Course Instructor. Use the content generated by the state[course_content] for a particular day and make interesting class that could finish within 70% of the time mentioned by the user. Be elaborate to ensure the user understands the concepts well, but also keep a track of time.""",
)

#5. Daily Custom Quiz Conductor Agent
class QuizConductorAgent(BaseAgent):
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator:
        print("Entered Quiz Conducting loop")
        # Get today's quiz from state
        quiz_data = ctx.session.state.get("quiz")
        if not quiz_data:
            print("No quiz found for today.")
            return

        # If quiz_data is a string, repair and parse it
        if isinstance(quiz_data, str):
            quiz_data = json.loads(repair_json(quiz_data))

        # If quiz is stored as a dict with day keys, get today's quiz
        current_day = ctx.session.state.get("current_day")
        if isinstance(quiz_data, dict) and current_day:
            quiz_list = quiz_data.get(f"day_{current_day}", [])
        elif isinstance(quiz_data, list):
            quiz_list = quiz_data
        else:
            quiz_list = []

        user_answers = []
        for idx, qa in enumerate(quiz_list):
            print(f"\nQuestion {idx+1}: {qa.get('question')}")
            options = qa.get('options', [])
            for opt_idx, opt in enumerate(options):
                print(f"  {opt_idx+1}. {opt}")
            while True:
                user_input = input("Your answer (enter option number or type your answer): ").strip()
                # Accept free-form answer or option number
                if options:
                    try:
                        answer_idx = int(user_input) - 1
                        if 0 <= answer_idx < len(options):
                            user_answer = options[answer_idx]
                            break
                        else:
                            print("Invalid option number. Please try again or type your answer.")
                    except ValueError:
                        # Accept as free-form answer
                        user_answer = user_input
                        break
                else:
                    user_answer = user_input
                    break
            user_answers.append(user_answer)
            ctx.session.state["user_answers"] = user_answers
            yield  # Optionally yield after each question

        print("Quiz complete!\n")

quiz_conductor_agent = QuizConductorAgent(name="DailyQuizConductorAgent")

# 6. Agent to evaluate responses
evaluation_agent = LlmAgent(
    name="QuizEvaluator",
    model=MODEL_NAME,
    instruction=(
        "Compare each user answer in state['user_answers'] to the correct answer in state['quiz']. "
        "For each, provide correctness and a brief review. "
        "Summarize the total score in state['score'] and provide a review in state['review']."
    )
)

# --- Custom Orchestrator Agent ---
class LearnLiteOrchestratorAgent(BaseAgent):
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator:
        # 1. Plan curriculum once
        async for event in curriculum_planner_agent.run_async(ctx):
            yield event
        curriculum_str = ctx.session.state.get('curriculum', {})
        curriculum_repair = repair_json(curriculum_str)
        curriculum = json.loads(curriculum_repair)
        if not curriculum:
            return

        for day, day_curriculum in curriculum.items():
            ctx.session.state['current_day'] = day
            ctx.session.state['current_curriculum'] = day_curriculum

            # Clear previous day's answers, score, review
            ctx.session.state.pop('user_answers', None)
            ctx.session.state.pop('score', None)
            ctx.session.state.pop('review', None)

            # 2. Generate content for the day
            async for event in content_generator_agent.run_async(ctx):
                yield event

            # 3. Generate quiz for the day
            async for event in quiz_maker.run_async(ctx):
                yield event

            # 4. Extract today's quiz and set in state['quiz']
            quiz_data = ctx.session.state.get("quiz")
            if isinstance(quiz_data, str):
                quiz_data = json.loads(repair_json(quiz_data))
            if isinstance(quiz_data, dict):
                todays_quiz = quiz_data.get(f"day_{day}", [])
            elif isinstance(quiz_data, list):
                todays_quiz = quiz_data
            else:
                todays_quiz = []
            ctx.session.state["quiz"] = todays_quiz

            # 5. Conduct class
            async for event in course_instructor.run_async(ctx):
                yield event
            # 6. Conduct quiz
            async for event in quiz_conductor_agent.run_async(ctx):
                yield event
            # 7. Evaluate
            async for event in evaluation_agent.run_async(ctx):
                yield event

root_agent = LearnLiteOrchestratorAgent(name="LearnLiteOrchestrator")